exit
n
@observer_peers
defined? @observer_state and @observer_state
defined?
k
v
k.send v
k.send
k.send v
v
k
n
@observer_peers
k
k.send
p
n
k.send
k.send v
@observer_peers
changed
exit
source_position
@transporters[source_position]
transport_destination
s
win?(current_player)
n
current_player
exit
EXIT
X:
X
 expect(observer).to have_received(:update).with(:ladder, :X, Game::Position.of(18), Game::Position.of(72))
game.play
allow(dice).to receive(:roll).and_return(3)
observer
n
move(player, transport_destination).class.class.class.class
move(player, transport_destination).class.class.class
move(player, transport_destination).class.class
move(player, transport_destination)
move(player, transport_destination).class
move(player, transport_destination)
notify_observers(event_type, current_player, source_position, transport_destination)
notify_observers
notifyobservers
event_type
event type
changed
changed(false)
changed
n
:chute.class
:chute
chute
xtext
exit
change_player
n
change_player
n
board_status
n
player
board_status
token_at(position.of(1))
token_at(position.of(1)) << player
position.of(1)
outcome
is_in_board?
exit
board[0][0] << :X
board[0][0]
board
c
exit
@box = Array.new(10){Array.new(10){|x| x = []}}
@game = SnakesLadders.new(:X, :O)
exit
destination
position
c
position
c
position
c
position
exit
position
postion
current_position
destination
exit
destination
c
destination
c
count
position
destination
starting.any?{|l| [l.x, l.y] == [Position.new(5,2).x, Position.new(5,2).y]}
