exit
move(current_token, 0, shift)
n
shift
n
@board
destination
n
destination
token_at(position).delete_if{|t| t == token }
t == token
position
n
current_position
n
current_position
current_position = Position.new(position.x, position.y)
position.y
position.x
position
p
p = Position.new(3,2)
current_position
Position.new(position.x, position.y)
current_position
n
exit
move(current_token, 0, shift)
head.each_with_index.map{|e,i| tail[i] if([destination.x, destination.y] == [e.x, e.y]) }.compact[0]
shift
destination
n
token_at(position).delete_if{|t| t == token}
token_at(position).delete(token)
token_at(position)
position
n
current_position
n
current_token
n
position
token
exit
position
token
exit
next
exit
@snakes.keys.any?{|p| [p.x, p.y] == [destination.x, destination.y] }
@snakes.keys.any?{|p| [p.x, p.y] == [desination.x, destination.y] }
@snakes.keys
destination
@snakes.keys
position
@snakes.keys.include?(destination)
@snakes.keys
@snakes
current_token
@board[destination.x][destination.y]
destination
current_position
position
count
token
exit
destination
token_at(position)
position
n
nn
n
nn
n
previous
token_at(position)
position
token_at(position).delete(token)
next
current_position
next
current_token
current_position
next
current_position
position
count
token
exit
position
c
position
c
position
c
position
c
position
c
exit
game.token_at(p1x8)
game.move(:X, 2, p5x0)
c
position
c
game.move(:X, 2, p5x0)
c
p
c
position
exit
position
exit
position
exit
position
postion
token
exit
c
position
count
token
exit
c
position
destination
count
token
exit
(game.token_at(p1x8))
p5x0
game.move(:X, 2, p5x0)
exit
c
position
destination
@snakes
c
v
k
destination
exit
position
x + count
x = Position.new(position.x,position.y)
position
count
position.y
position.x
x
position = position + count
x = position
exit
current_position
destination
position
exit
position
destination
current_position
exit
destination
position
exit
position
exit
position
destination
next
destination
current_position
position
next
position
exit
position
c
position
token_at(position).delete_if{|t| t == token }
position
next
c
current_position
current_token
currnt token
token
position
exit
p0x8
exit
position
exit
p1x2
p0x8
exit
c
token_at(position).delete_if{|t| t == token }
destination
position
token
c
game.token_at(p0x8)
game.token_at(p1x2)
exit
game.token_at(p0x7)
token
continue
position
exit
destination
next
destination
next
destination
count
position
token
c
position
token
c
position
count
token
c
game.token_at(p0x8)
exit
EXIT
token
 token_at(position)
exit
game.place(p0x8, :X)
game.token_at(p0x8)
game.token_at(p1x2)
game.token
token
game.place
c
position
c
x
c
token
position
place
position
exit
place((position +(count)), token)
position + count
token
count
position
exit
exity
exit
