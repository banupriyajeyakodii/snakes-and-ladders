c
exit
@box = Array.new(10){Array.new(10){|x| x = []}}
@game = SnakesLadders.new(:X, :O)
exit
destination
position
c
position
c
position
c
position
exit
position
postion
current_position
destination
exit
destination
c
destination
c
count
position
destination
starting.any?{|l| [l.x, l.y] == [Position.new(5,2).x, Position.new(5,2).y]}
starting.any?{|l| [l.x, l.y] == [destination.x, destination.y]}
head.each_with_index.map{|e,i| tail[i] if([destination.x, destination.y] == [e.x, e.y]) }.compact[0]
head.each_with_index.map{|e,i| tail[i] if([destination.x, destination.y] == [e.x, e.y]) }
head.each_with_index.map{|e,i| tail[i] if([destination.x, destination.y] == [e.x, e.y]) }.compact
head.each_with_index.map{|e,i| tail[i] if([destination.x, destination.y] == [e.x, e.y]) }
tail = @snakes.values
head = @snakes.keys
ar
ar = @snakes.to_a
@snakes.to_a
@snakes
@snakes[destination]
destination
@snakes.keys.any?{|p| [p.x, p.y] == [destination.x, destination.y] }
current_token
exit
next
exit
@snakes.keys.any?{|p| [p.x, p.y] == [destination.x, destination.y] }
@snakes.keys.any?{|p| [p.x, p.y] == [desination.x, destination.y] }
@snakes.keys
destination
@snakes.keys
position
@snakes.keys.include?(destination)
@snakes.keys
@snakes
current_token
@board[destination.x][destination.y]
destination
current_position
position
count
token
exit
destination
token_at(position)
position
n
nn
n
nn
n
previous
token_at(position)
position
token_at(position).delete(token)
next
current_position
next
current_token
current_position
next
current_position
position
count
token
exit
position
c
position
c
position
